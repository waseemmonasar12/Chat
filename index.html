<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat Secure Pro üõ°Ô∏è</title>
    
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#00a884">
    <link rel="apple-touch-icon" href="icon-192.png">

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700&display=swap" rel="stylesheet">

    <style>
        :root { --primary: #00a884; --bg-glass: rgba(10, 20, 30, 0.9); --msg-me: #005c4b; --msg-other: #202c33; --text-light: #e9edef; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Cairo', sans-serif; margin: 0; height: 100vh; overflow: hidden; background: #0b141a; color: var(--text-light); display: flex; justify-content: center; align-items: center; }
        .app-container { width: 100%; height: 100%; max-width: 1400px; display: flex; position: relative; overflow: hidden; background: #111b21; }
        @media (min-width: 768px) { .app-container { height: 95vh; width: 95vw; border-radius: 20px; box-shadow: 0 0 50px rgba(0,0,0,0.5); border: 1px solid #333; } }
        
        /* Sidebar & Chat Layout */
        .sidebar { width: 30%; border-left: 1px solid #333; display: flex; flex-direction: column; background: #111b21; }
        .chat-area { flex: 1; display: flex; flex-direction: column; background-image: url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png'); background-color: #0b141a; position: relative; }
        .chat-overlay { position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(11,20,26,0.9); z-index:0; }
        
        /* Components */
        .auth-screen { position: absolute; z-index: 1000; width: 100%; height: 100%; background: #111b21; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .btn-google { background: white; color: #333; padding: 10px 20px; border-radius: 5px; cursor: pointer; display: flex; align-items: center; gap: 10px; font-weight: bold; border: none; }
        
        .header { padding: 10px 16px; background: #202c33; display: flex; align-items: center; justify-content: space-between; z-index: 10; }
        .user-item { padding: 12px; display: flex; align-items: center; gap: 15px; cursor: pointer; border-bottom: 1px solid #222; transition: 0.2s; }
        .user-item:hover { background: #202c33; }
        
        .messages { flex: 1; overflow-y: auto; padding: 20px; z-index: 10; display: flex; flex-direction: column; gap: 5px; }
        .msg { max-width: 65%; padding: 6px 10px; border-radius: 8px; position: relative; font-size: 14px; line-height: 1.4; word-wrap: break-word; }
        .msg.me { align-self: flex-end; background: var(--msg-me); border-radius: 8px 0 8px 8px; }
        .msg.other { align-self: flex-start; background: var(--msg-other); border-radius: 0 8px 8px 8px; }
        
        .input-area { padding: 10px; background: #202c33; z-index: 10; display: flex; gap: 10px; align-items: center; }
        input[type="text"] { flex: 1; padding: 10px; border-radius: 8px; border: none; background: #2a3942; color: white; outline: none; }
        
        /* Status Indicators */
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background: gray; border: 2px solid #111b21; }
        .status-dot.online { background: #00a884; }
        
        .hidden { display: none !important; }
        
        /* Mobile */
        @media (max-width: 768px) {
            .sidebar { width: 100%; position: absolute; z-index: 20; height: 100%; transform: translateX(0); transition: 0.3s; }
            .sidebar.closed { transform: translateX(100%); }
        }
    </style>
</head>
<body>

    <div id="authScreen" class="auth-screen">
        <h1 style="color: var(--primary);">üîê Chat Secure Pro</h1>
        <p>ÿ™ÿ¥ŸÅŸäÿ± ÿ∑ÿ±ŸÅ-ÿ•ŸÑŸâ-ÿ∑ÿ±ŸÅ (ECDH)</p>
        <button class="btn-google" onclick="authManager.login()">
            <img src="https://upload.wikimedia.org/wikipedia/commons/5/53/Google_%22G%22_Logo.svg" width="20">
            ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿ¨Ÿàÿ¨ŸÑ
        </button>
        <p id="authStatus" style="margin-top:20px; font-size:12px; color:gray;"></p>
    </div>

    <div id="appContainer" class="app-container hidden">
        <div id="sidebar" class="sidebar">
            <div class="header">
                <div style="display:flex; align-items:center; gap:10px;">
                    <img id="myAvatar" src="" style="width:40px; height:40px; border-radius:50%;">
                    <span id="myName"></span>
                </div>
                <i class="fas fa-sign-out-alt" onclick="authManager.logout()" style="cursor:pointer;"></i>
            </div>
            <div id="usersList" style="flex:1; overflow-y:auto;"></div>
        </div>

        <div id="chatArea" class="chat-area">
            <div class="chat-overlay"></div>
            <div class="header" id="chatHeader" style="display:none;">
                <div style="display:flex; align-items:center; gap:10px;">
                    <i class="fas fa-arrow-right" onclick="uiManager.toggleSidebar(true)" style="cursor:pointer; display:none;" id="backBtn"></i>
                    <img id="chatAvatar" src="" style="width:35px; height:35px; border-radius:50%;">
                    <div id="chatName" style="font-weight:bold;"></div>
                </div>
            </div>
            <div id="messagesContainer" class="messages"></div>
            <div class="input-area" id="inputArea" style="display:none;">
                <label style="cursor:pointer;"><i class="fas fa-camera" style="color:#8696a0;"></i>
                    <input type="file" hidden id="imgInput" accept="image/*" onchange="chatManager.uploadImage(this)">
                </label>
                <input type="text" id="msgInput" placeholder="ÿßŸÉÿ™ÿ® ÿ±ÿ≥ÿßŸÑÿ©...">
                <button onclick="chatManager.sendMessage()" style="background:none; border:none; color:var(--primary); font-size:20px; cursor:pointer;"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "ÿ∂ÿπ_ŸÖŸÅÿ™ÿßÿ≠_API_ŸáŸÜÿß",
            authDomain: "ÿ∂ÿπ_ŸÜÿ∑ÿßŸÇ_Auth_ŸáŸÜÿß",
            databaseURL: "ÿ∂ÿπ_ÿ±ÿßÿ®ÿ∑_ÿßŸÑŸÇÿßÿπÿØÿ©_ŸáŸÜÿß",
            projectId: "ÿ∂ÿπ_ŸÖÿπÿ±ŸÅ_ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ_ŸáŸÜÿß",
            storageBucket: "ÿ∂ÿπ_ÿ±ÿßÿ®ÿ∑_ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ_ŸáŸÜÿß",
            messagingSenderId: "ÿ∂ÿπ_ÿ±ŸÇŸÖ_ÿßŸÑŸÖÿ±ÿ≥ŸÑ_ŸáŸÜÿß",
            appId: "ÿ∂ÿπ_ŸÖÿπÿ±ŸÅ_ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ_ŸáŸÜÿß"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        const auth = firebase.auth();
        const storage = firebase.storage();

        // --- CRYPTO MANAGER ---
        class CryptoManager {
            constructor() { this.keyPair = null; }
            async generateKeys() {
                this.keyPair = await window.crypto.subtle.generateKey({ name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey", "deriveBits"]);
                return this.keyPair;
            }
            async exportPublicKey() { return await window.crypto.subtle.exportKey("jwk", this.keyPair.publicKey); }
            async exportPrivateKey() { return await window.crypto.subtle.exportKey("jwk", this.keyPair.privateKey); }
            async loadMyKeys(pubJWK, privJWK) {
                const pub = await window.crypto.subtle.importKey("jwk", pubJWK, { name: "ECDH", namedCurve: "P-256" }, true, []);
                const priv = await window.crypto.subtle.importKey("jwk", privJWK, { name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey", "deriveBits"]);
                this.keyPair = { publicKey: pub, privateKey: priv };
            }
            async importOtherPublicKey(jwk) { return await window.crypto.subtle.importKey("jwk", jwk, { name: "ECDH", namedCurve: "P-256" }, false, []); }
            async deriveSharedKey(otherPublicKey) {
                return await window.crypto.subtle.deriveKey({ name: "ECDH", public: otherPublicKey }, this.keyPair.privateKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
            }
            async encrypt(text, sharedKey) {
                const enc = new TextEncoder();
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, sharedKey, enc.encode(text));
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv); combined.set(new Uint8Array(encrypted), iv.length);
                return this.buf2hex(combined);
            }
            async decrypt(hexString, sharedKey) {
                try {
                    const combined = this.hex2buf(hexString);
                    const iv = combined.slice(0, 12);
                    const data = combined.slice(12);
                    const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, sharedKey, data);
                    return new TextDecoder().decode(decrypted);
                } catch (e) { return "üîí ÿ±ÿ≥ÿßŸÑÿ© ÿ∫Ÿäÿ± ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑŸÇÿ±ÿßÿ°ÿ©"; }
            }
            buf2hex(buffer) { return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join(''); }
            hex2buf(hex) { return new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))); }
        }

        // --- UI MANAGER ---
        class UIManager {
            constructor() { this.users = {}; }
            showApp(user) {
                document.getElementById('authScreen').classList.add('hidden');
                document.getElementById('appContainer').classList.remove('hidden');
                document.getElementById('myName').innerText = user.displayName;
                document.getElementById('myAvatar').src = user.photoURL;
                if(window.innerWidth < 768) document.getElementById('backBtn').style.display = 'block';
            }
            renderUser(uid, userData) {
                if(uid === authManager.currentUser.uid) return;
                this.users[uid] = userData;
                const div = document.createElement('div');
                div.className = 'user-item';
                div.onclick = () => chatManager.openChat(uid);
                const statusColor = userData.state === 'online' ? '#00a884' : 'gray';
                div.innerHTML = `
                    <div style="position:relative;"><img src="${userData.photoURL}" style="width:45px; height:45px; border-radius:50%;">
                    <div class="status-dot" style="position:absolute; bottom:0; left:0; background:${statusColor}"></div></div>
                    <div><div style="font-weight:bold">${userData.displayName}</div></div>`;
                document.getElementById('usersList').appendChild(div);
            }
            appendMessage(msg, type, isMe) {
                const div = document.createElement('div');
                div.className = `msg ${isMe ? 'me' : 'other'}`;
                let content = type === 'text' ? msg : `<img src="${msg}" style="max-width:200px; border-radius:8px;" onclick="window.open(this.src)">`;
                div.innerHTML = content;
                const container = document.getElementById('messagesContainer');
                container.appendChild(div);
                container.scrollTop = container.scrollHeight;
            }
            toggleSidebar(show) {
                const sidebar = document.getElementById('sidebar');
                if(show) sidebar.classList.remove('closed'); else sidebar.classList.add('closed');
            }
        }

        // --- AUTH MANAGER ---
        class AuthManager {
            constructor() { this.currentUser = null; }
            async login() {
                const provider = new firebase.auth.GoogleAuthProvider();
                try { const result = await auth.signInWithPopup(provider); this.handleUserInit(result.user); } 
                catch (error) { alert("Error: " + error.message); }
            }
            async handleUserInit(user) {
                this.currentUser = user;
                const userRef = db.ref('users/' + user.uid);
                const snap = await userRef.once('value');
                const existingData = snap.val();
                if (!existingData || !localStorage.getItem(`priv_${user.uid}`)) {
                    document.getElementById('authStatus').innerText = "ÿ¨ÿßÿ±Ÿä ÿ™ŸàŸÑŸäÿØ ŸÖŸÅÿßÿ™Ÿäÿ≠ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±...";
                    await cryptoManager.generateKeys();
                    const pubKey = await cryptoManager.exportPublicKey();
                    const privKey = await cryptoManager.exportPrivateKey();
                    localStorage.setItem(`priv_${user.uid}`, JSON.stringify(privKey));
                    await userRef.update({ displayName: user.displayName, email: user.email, photoURL: user.photoURL, publicKey: pubKey, uid: user.uid, state: 'online' });
                } else {
                    const privKey = JSON.parse(localStorage.getItem(`priv_${user.uid}`));
                    await cryptoManager.loadMyKeys(existingData.publicKey, privKey);
                    await userRef.update({ state: 'online' });
                }
                db.ref('.info/connected').on('value', snap => {
                    if(snap.val()) { userRef.onDisconnect().update({ state: 'offline' }); userRef.update({ state: 'online' }); }
                });
                uiManager.showApp(user);
                this.loadUsers();
            }
            loadUsers() { db.ref('users').on('child_added', snap => uiManager.renderUser(snap.key, snap.val())); }
            logout() { auth.signOut(); location.reload(); }
        }

        // --- CHAT MANAGER ---
        class ChatManager {
            constructor() { this.activeChatId = null; this.sharedKeysCache = {}; }
            async openChat(targetUid) {
                this.activeChatId = targetUid;
                const targetUser = uiManager.users[targetUid];
                document.getElementById('messagesContainer').innerHTML = '';
                document.getElementById('chatHeader').style.display = 'flex';
                document.getElementById('inputArea').style.display = 'flex';
                document.getElementById('chatName').innerText = targetUser.displayName;
                document.getElementById('chatAvatar').src = targetUser.photoURL;
                if(window.innerWidth < 768) uiManager.toggleSidebar(false);
                if (!this.sharedKeysCache[targetUid]) {
                    const targetKey = await cryptoManager.importOtherPublicKey(targetUser.publicKey);
                    this.sharedKeysCache[targetUid] = await cryptoManager.deriveSharedKey(targetKey);
                }
                const chatId = [authManager.currentUser.uid, targetUid].sort().join('_');
                this.listenForMessages(chatId);
            }
            listenForMessages(chatId) {
                db.ref(`messages/${chatId}`).off();
                db.ref(`messages/${chatId}`).limitToLast(20).on('child_added', async snap => {
                    const data = snap.val();
                    const sharedKey = this.sharedKeysCache[this.activeChatId];
                    const decryptedContent = await cryptoManager.decrypt(data.content, sharedKey);
                    const isMe = data.sender === authManager.currentUser.uid;
                    uiManager.appendMessage(decryptedContent, data.type, isMe);
                });
            }
            async sendMessage() {
                const inp = document.getElementById('msgInput');
                const txt = inp.value.trim();
                if(!txt || !this.activeChatId) return;
                const sharedKey = this.sharedKeysCache[this.activeChatId];
                const encrypted = await cryptoManager.encrypt(txt, sharedKey);
                const chatId = [authManager.currentUser.uid, this.activeChatId].sort().join('_');
                await db.ref(`messages/${chatId}`).push({ sender: authManager.currentUser.uid, content: encrypted, type: 'text', timestamp: firebase.database.ServerValue.TIMESTAMP });
                inp.value = '';
            }
            async uploadImage(input) {
                const file = input.files[0];
                if (!file || !this.activeChatId) return;
                const ref = storage.ref(`chat_images/${Date.now()}_${file.name}`);
                const snap = await ref.put(file);
                const url = await snap.ref.getDownloadURL();
                const sharedKey = this.sharedKeysCache[this.activeChatId];
                const encryptedUrl = await cryptoManager.encrypt(url, sharedKey);
                const chatId = [authManager.currentUser.uid, this.activeChatId].sort().join('_');
                await db.ref(`messages/${chatId}`).push({ sender: authManager.currentUser.uid, content: encryptedUrl, type: 'image', timestamp: firebase.database.ServerValue.TIMESTAMP });
            }
        }

        const cryptoManager = new CryptoManager();
        const uiManager = new UIManager();
        const authManager = new AuthManager();
        const chatManager = new ChatManager();
        if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js'); }
    </script>
</body>
</html>
